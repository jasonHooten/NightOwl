var nightowl = require ('../lib/nightowl');
var assert = require ('assert');
var storage_mocked = require ('./lib/mock/storage_mocked');

describe('ping service', function(){

  var temp_status = null;
  var temp_last_outage = null;

  var failed_request_timestamp = null;
  var correct_request_timestamp = null;
  var warning_request_timestamp = null;

  var service = {
    host : {host: 'www.correcthost.com', port:'80', name : 'test'},
    url : '/',
    ping_interval: 4,
    failed_ping_interval: 5,
    warning_if_takes_more_than: 1500, //miliseconds
    method : 'get',
    expected : {statuscode: 200, contains: ''}
  };

  var mocked_ping_service = require ('./lib/mock/request_mocked');
  service.ping_service = mocked_ping_service;

  describe('bad request', function(){

    var _nightowl = null;

    before(function(done){
      failed_request_timestamp = +new Date();
      mocked_ping_service.mocked_response = {error: 'mocked   error', body : null, response : null, timeDiff : 0};
      _nightowl = new nightowl(null, new storage_mocked(null));
      done();
    });

    it('should emit error', function(done){
      _nightowl.on('service_ok', function (service, status){
        done('error. bad response - dns request');
      });

      _nightowl.on('service_error', function (service, status){
        temp_status = status;
        done(null);
      });

      _nightowl.ping({service:service, timestamp: failed_request_timestamp}, function(err, request_status){
        assert.ifError(err);
      });
    });

    it('should have last_check property', function(done){
      assert.equal (temp_status.last_check, failed_request_timestamp);
      done();
    });

    it('should have running_since property', function(done){
      assert.equal (temp_status.running_since, failed_request_timestamp);
      done();
    });

    it('should have right status error', function(done){
      assert.equal (temp_status.status, "error");
      done();
    });

    it('should have last_outage', function(done){
      assert.ok (temp_status.last_outage);
      temp_last_outage = temp_status.last_outage; //save for next test
      done();
    });

    it('should have right delay for next attempt', function(done){
      assert.equal (temp_status.next_attempt_secs, service.failed_ping_interval);
      done();
    });

    it('should have an error event', function(done){
      assert.equal (temp_status.events[0].status, 'error');
      done();
    });

    it('should have a down_timestamp value', function(done){
      assert.equal (temp_status.down_timestamp, failed_request_timestamp);
      done();
    });

    it('should NOT have a downtime value yet', function(done){
      assert.ok (!temp_status.down_time_last_request);
      done();
    });

    it('should NOT have a prev_state yet', function(done){
      assert.equal (JSON.stringify(temp_status.prev_state),'{}');
      done();
    });

    it('should have a running_since value', function(done){
      assert.equal (temp_status.running_since, failed_request_timestamp);
      done();
    });

    it('should have 1 outage', function(done){
      assert.equal (temp_status.outages, 1);
      done();
    });

    it('should NOT have a up_since value yet', function(done){
      assert.ok (!temp_status.up_since);
      done();
    });

    it('should have zero uptime', function(done){
      assert.equal (temp_status.uptime, 0);
      done();
    });

    it('should NOT have ok_responses', function(done){
      assert.equal (temp_status.ok_responses_count, 0);
      done();
    });

    it('should NOT have avg_response_time value', function(done){
      assert.ok (!temp_status.avg_response_time);
      done();
    });
  });

  describe('correct (service back) request', function(){

    var _nightowl = null;

    before(function(done){
      correct_request_timestamp = failed_request_timestamp + 60*1000; //one minute later
      mocked_ping_service.mocked_response = {error: null, body : 'ok', response : {body: 'ok', statusCode: 200}, timeDiff : 300};
      _nightowl = new nightowl(null, new storage_mocked(temp_status));
      done();
    });

    it('should emit service_back', function(done){
      _nightowl.on('service_back', function (service, status){
        temp_status = status;
        done(null);
      });

      _nightowl.on('service_error', function (service, status){
        done('error. bad response');
      });

      _nightowl.ping({service:service, timestamp: correct_request_timestamp}, function(err, request_status){
        assert.ifError(err);
      });
    });

    it('should have last_check', function(done){
      assert.equal (temp_status.last_check, correct_request_timestamp);
      done();
    });

    it('should have running_since property', function(done){
      assert.equal (temp_status.running_since, failed_request_timestamp);
      done();
    });

    it('should have prev_state', function(done){
      assert.ok (temp_status.prev_state);
      done();
    });

    it('should not have a nested prev_state property', function(done){
        assert.ok (!temp_status.prev_state.prev_state);
        done();
    });

    it('should have right status', function(done){
      assert.equal (temp_status.status, "success");
      done();
    });

    it('should have last_outage', function(done){
      assert.equal (temp_status.last_outage, temp_last_outage);
      done();
    });

    it('should have right delay for next attempt', function(done){
      assert.equal (temp_status.next_attempt_secs, service.ping_interval);
      done();
    });

    it('should have service_back event', function(done){
      assert.equal (temp_status.events.length, 1);
      done();
    });

    it('should NOT have a down_timestamp value', function(done){
      assert.ok (!temp_status.down_timestamp);
      done();
    });

    it('should have a up_since value', function(done){
      assert.equal (temp_status.up_since, correct_request_timestamp);
      done();
    });

    it('should have a downtime value', function(done){
      //corresponding to the last failed request
      assert.equal (temp_status.down_time_last_request, (correct_request_timestamp-failed_request_timestamp)/1000); //in seconds
      done();
    });

    it('should have an accumulated downtime value', function(done){
      assert.equal (temp_status.down_time_acc, (correct_request_timestamp-failed_request_timestamp)/1000); //in seconds
      done();
    });

    it('should have 1 outage from last invalid request', function(done){
      assert.equal (temp_status.outages, 1);
      done();
    });

    it('should have zero uptime', function(done){
      assert.equal (temp_status.uptime, 0);
      done();
    });

    it('should have 1 successful response', function(done){
      assert.equal (temp_status.ok_responses_count, 1);
      done();
    });

    it('should have avg_response_time value', function(done){
      assert.equal (temp_status.avg_response_time, 300);
      done();
    });
  });


  describe('warning request', function(){

    var _nightowl = null;

    before(function(done){
      warning_request_timestamp = failed_request_timestamp + 2 * 60 * 1000; //one minute later
      mocked_ping_service.mocked_response = {error: null, body : 'ok', response : {body: 'ok', statusCode: 200}, timeDiff : 22300};
      _nightowl = new nightowl(null, new storage_mocked(temp_status));
      done();
    });

    it('should emit service_back', function(done){
      _nightowl.on('service_warning', function (service, status){
        temp_status = status;
        done(null);
      });

      _nightowl.on('service_error', function (service, status){
        done('error. bad response');
      });

      _nightowl.ping({service:service, timestamp: warning_request_timestamp}, function(err, request_status){
        assert.ifError(err);
      });
    });

    it('should have last_check', function(done){
      assert.equal (temp_status.last_check, warning_request_timestamp);
      done();
    });

    it('should have running_since property', function(done){
      assert.equal (temp_status.running_since, failed_request_timestamp);
      done();
    });

    it('should have prev_state', function(done){
      assert.ok (temp_status.prev_state);
      done();
    });

    it('should not have a nested prev_state property', function(done){
        assert.ok (!temp_status.prev_state.prev_state);
        done();
    });

    it('should have right status', function(done){
      assert.equal (temp_status.status, "success");
      done();
    });

    it('should have last_outage', function(done){
      assert.equal (temp_status.last_outage, temp_last_outage);
      done();
    });

    it('should have right delay for next attempt', function(done){
      assert.equal (temp_status.next_attempt_secs, service.ping_interval);
      done();
    });

    it('should have service_back event', function(done){
      assert.equal (temp_status.events.length, 1);
      done();
    });

    it('should have NOT a down_timestamp value', function(done){
      assert.ok (!temp_status.down_timestamp);
      done();
    });

    it('should have NOT a downtime value', function(done){
      assert.ok (!temp_status.down_time_last_request);
      done();
    });

    it('should have an accumulated downtime value', function(done){
      assert.equal (temp_status.down_time_acc, (correct_request_timestamp-failed_request_timestamp)/1000); //in seconds
      done();
    });

    it('should have a up_since value', function(done){
      assert.equal (temp_status.up_since, correct_request_timestamp);
      done();
    });

    it('should have 1 outage from last invalid request', function(done){
      assert.equal (temp_status.outages, 1);
      done();
    });

    it('should have more than zero uptime', function(done){
      assert.equal (temp_status.uptime, 50);
      done();
    });

    it('should have 2 successful responses', function(done){
      assert.equal (temp_status.ok_responses_count, 2);
      done();
    });

    it('should have avg_response_time value', function(done){
      assert.equal (temp_status.avg_response_time, 11300);
      done();
    });
  });
});